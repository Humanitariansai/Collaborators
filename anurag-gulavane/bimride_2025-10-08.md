# Daily Progress Report – October 8, 2025

## Overview
Today I focused on **memory management**, especially how different languages handle allocation, garbage collection, and memory safety. 
Understanding these concepts helps design backend systems that are fast, predictable, and resilient.

---

## Activities
### **1. Studied Manual vs Automatic Memory Management**
I compared:
- Manual (C/C++)  
- Automatic GC (Java, Go)  
- Ownership models (Rust)  

This helped me understand how memory models affect backend performance.

### **2. Explored Garbage Collection (GC) Internals**
I reviewed:
- mark-and-sweep  
- generational GC  
- stop-the-world pauses  

I analyzed how GC pauses could impact real-time processes like routing or price estimation.

### **3. Tested Memory Profiling Tools**
I looked at heap snapshots and memory leak detectors.  
This made it clear how slow memory growth can degrade mobility performance over time.

### **4. Designed Memory-Safe Backend Approaches for Bimride**
For example:
- using Go for routing/proxy services  
- using Rust for performance-critical modules  
- designing services to avoid large allocations  

This reinforced how memory discipline affects system reliability.

---

## How Today’s Work Ties to Bimride
### **1. Faster Routing & Pricing**
Well-managed memory reduces latency in key Bimride services.

### **2. Greater Stability**
Memory-safe designs reduce crashes during high traffic.

### **3. Better Long-Term Performance**
Preventing leaks ensures Bimride stays fast as data grows.

### **4. Improved Engineering Discipline**
Memory awareness shapes how Bimride builds scalable, clean backend services.
