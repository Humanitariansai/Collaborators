
# Daily Progress Report – November 6, 2025

## Overview
Today I explored **event sourcing** as a foundational architectural pattern for Bimride’s long-term data integrity, trip history reliability, and operational analytics. Unlike traditional CRUD systems—where data is overwritten each time a value changes—event sourcing stores *every change as an immutable event*. Instead of “current state,” the system stores the **full history of how the state came to be**.

For a mobility platform like Bimride, this matters enormously. A ride-hailing trip isn’t just a static object; it’s a dynamic sequence of events:

- rider creates request  
- driver accepts  
- driver begins traveling  
- rider boards  
- trip begins  
- GPS updates stream  
- pricing factors change  
- trip completes  
- payment finalizes  

Every one of these steps represents a meaningful business event. Storing only the final snapshot loses all intermediate insights—the patterns that power analytics, customer support, fraud prevention, post-trip investigation, and future ML models.

Event sourcing gives Bimride:
- a complete audit trail  
- replayable trip histories  
- clean chronological event logs  
- data consistency across microservices  
- support for real-time features like dashboards and alerts  

Today’s work fully reshaped how I view Bimride’s internal architecture.

---

## Activities

### 1. Broke down the difference between CRUD and event-sourced architectures
I started by contrasting traditional state storage vs. event sourcing:

**CRUD model:**
- overwrites values  
- loses intermediate states  
- harder to debug  
- prone to race conditions  
- poor for analytics without extra tables  

**Event sourcing model:**
- append-only log of events  
- reconstructable state  
- perfect audit trail  
- chronological consistency  
- ideal for time-series analytics  

This helped me see why Uber, Lyft, and Bolt eventually adopted event-driven patterns once their scale grew.

### 2. Identified key event types in a Bimride trip lifecycle
I mapped out events that occur from start to finish. Examples:

- `RIDE_REQUESTED`  
- `DRIVER_ASSIGNED`  
- `DRIVER_ACCEPTED`  
- `DRIVER_LOCATION_UPDATE`  
- `DRIVER_ARRIVED`  
- `RIDER_BOARDED`  
- `TRIP_STARTED`  
- `GPS_UPDATE`  
- `PRICE_UPDATED`  
- `TRIP_COMPLETED`  
- `PAYMENT_CHARGED`  

Each event contains:
- timestamp  
- actor (driver, rider, system)  
- metadata (GPS, pricing, reason, etc.)  
- correlation IDs  
- sequence numbers  

This creates a predictable, replayable sequence of actions.

### 3. Studied how event stores differ from standard databases
I researched common storage options:
- Apache Kafka  
- Pulsar  
- DynamoDB streams  
- Redis streams  
- EventStoreDB  
- PostgreSQL with append-only tables  

For Bimride’s early phase:
- PostgreSQL append-only tables + Kafka for projections is ideal.  
Affordable, reliable, and easy to extend.

### 4. Learned how snapshots improve performance
Rebuilding entire ride state from hundreds of events can be expensive.  
Snapshots store periodic state summaries.

I designed a snapshotting strategy:
- create snapshot every 25 events  
- store current ride status, active pricing, and last location  
- rebuild starting from latest snapshot + new events  

This keeps queries fast without losing historical detail.

### 5. Modeled event replay for debugging and analytics
Event replay allows:
- reconstructing past trips step-by-step  
- simulating pricing changes  
- reproducing bugs  
- validating new features against old data  

I created a replay flow:
1. Load all events for trip X  
2. Feed through state reducer  
3. Output final state  
4. Optional: visualize timeline for customer support  

This is critical when tourists complain about incorrect routes or unexpected charges.

### 6. Explored how event sourcing supports multiple microservices
Microservices subscribe to events instead of tightly coupling:

- Ride service emits events  
- Pricing service listens  
- Analytics listens  
- Map-matching listens  
- Notification service listens  

This allows:
- independent evolution  
- clean modularity  
- low coupling  
- real-time updates  

Perfect for Bimride’s future scaling.

### 7. Designed how Bimride handles GPS event streams
GPS updates happen frequently.  
Instead of storing only the latest coordinate:
- store every coordinate as an event  
- run map-matching on ingestion  
- compress stale GPS entries after trip closes  

This enables:
- high-resolution trip playback  
- driver behavior analysis  
- road quality modeling in Barbados  

Even local transport authorities may benefit from anonymized data insights.

### 8. Studied pricing mutations as event streams
Pricing isn’t static—it changes during the trip. For example:
- surge adjustments  
- traffic delays  
- distance recalculations  

Event sourcing captures:
- price changes in order  
- what triggered the change  
- how many times recalculation happened  

Bimride can later use this for fare dispute resolution.

### 9. Designed projections to build read-optimized models
Event stores are write-optimized.  
Projections materialize events into read models.

For example:
**Trips table** (read model) would be built from:
- RIDE_REQUESTED  
- DRIVER_ACCEPTED  
- TRIP_STARTED  
- TRIP_COMPLETED  

Similarly:
- driver stats projection  
- revenue projection  
- cancellation rate projection  
- heatmap projection (location-based demand)  

Projections allow Bimride to build:
- dashboards  
- analytics  
- machine learning inputs  
- financial reports  

Everything from a single source of truth.

### 10. Studied how to prevent event-ordering problems
Distributed systems often produce out-of-order events due to:
- network jitter  
- clock skew  
- retry logic  

I designed safeguards:
- server-side timestamps  
- monotonically increasing sequence IDs  
- rejection of stale events  
- partial ordering by actor (driver events vs rider events)  

This keeps trip histories consistent and trustworthy.

---

## How Today’s Work Ties to Bimride

### 1. Creates perfect trip histories
With event sourcing:
- no detail is lost  
- every update is traceable  
- support agents can see exact timelines  
- disputes become easier to resolve  

This builds credibility—especially important in tourism-heavy markets.

### 2. Enables high-quality analytics for pricing and routing
Event streams power:
- surge heatmaps  
- peak-hour patterns  
- road-speed modeling  
- driver efficiency metrics  
- ETA calibration models  

This transforms Bimride from “just an app” into a data-driven logistics system.

### 3. Makes debugging far easier
If something goes wrong:
- replay the ride  
- inspect state transitions  
- validate pricing logic  
- replicate bug conditions  

This drastically cuts engineering time.

### 4. Helps detect fraud early
Event sequences reveal:
- abnormal trip patterns  
- location spoofing  
- device-switching fraud  
- manipulated GPS  
- driver “gaming” behavior  

This protects both riders and the platform.

### 5. Supports future features like incentives & loyalty
Events can feed:
- driver rewards  
- streak tracking  
- on-time arrival bonuses  
- rider loyalty points  
- corporate billing  

Event sourcing makes these features trivial.

### 6. Future-proofs Bimride’s architecture
This pattern will scale cleanly as Bimride grows beyond Barbados:
- new islands  
- new service types  
- new app flows  
- new pricing models  

Nothing breaks because events are backward-compatible.

---

Overall, today’s work built a foundational part of Bimride’s eventual backend—an append-only, chronological, audit-safe event system that will enable powerful features and keep operations transparent, predictable, and resilient.

