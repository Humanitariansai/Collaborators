# Daily Progress Report – September 24, 2025

## Overview
Today’s focus was on **database indexing strategies**, which dramatically improve query speed and reduce database load. The goal was to understand how smart indexing directly affects Bimride’s performance when fetching driver locations, trip histories, or real-time pricing data.

---

## Activities

### **1. Studied B-Tree Indexes**
B-Trees accelerate range queries, making them perfect for:
- recent trips  
- time-based filtering  
- driver availability windows

### **2. Learned About Hash Indexes**
Hash indexes support fast equality lookups.  
Useful for:
- finding users by ID  
- fetching a single trip  
- validating credentials

### **3. Explored Composite Indexes**
Composite (multi-column) indexes optimize queries like:
- trips by rider + date  
- drivers by region + availability  
These appear constantly in mobility platforms.

### **4. Designed Indexes for Bimride’s Schema**
I drafted indexes for:
- `drivers(status, last_active_time)`  
- `trips(rider_id, created_at)`  
- `pricing_logs(zone, timestamp)`  

This made clear which fields should be indexed early for speed and which should be avoided to prevent bloat.

---

## How Today’s Work Ties to Bimride

### **1. Faster Driver Matching**
Indexes drastically reduce the time needed to find nearby drivers.

### **2. Better User Experience**
Trip history loads immediately when the data layer is optimized.

### **3. Scalability Across the Caribbean**
As Bimride grows, indexed queries remain fast even with millions of rows.

### **4. Lower Infrastructure Costs**
Fast queries = less CPU = smaller database bills.
