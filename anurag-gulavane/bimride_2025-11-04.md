
# Daily Progress Report – November 4, 2025

## Overview
Today I worked deeply on **ride request lifecycle modeling**, a foundational concept for any mobility platform. While at first glance “a ride request” sounds simple—rider taps a button, driver accepts, trip starts—the truth is far more complex. A modern ride-hailing system involves a precise sequence of state transitions, distributed coordination, failure handling, retries, network uncertainty, and business logic branching that must all work flawlessly for the user experience to feel effortless.

For Bimride, modeling the ride lifecycle properly means fewer rider-driver mismatches, fewer cancelled trips, more predictable ETAs, smoother payments, and a platform that feels trustworthy and professional to both locals and tourists. Barbados’ environment—variable network quality, busy city clusters in Bridgetown, narrow one-way roads, and inconsistent GPS readings—makes it even more essential that Bimride’s internal ride state machine is robust, fault-tolerant, and able to gracefully handle unexpected disruptions.

Today’s work was about designing that backbone: the unambiguous chain of events that define the life of a ride, the transitions allowed, the transitions forbidden, the events that can interrupt the flow, and how Bimride should respond to edge cases. I wanted to create a lifecycle that is clean, expressive, analyzable, and easily extendable as the platform grows.

---

## Activities

### 1. Broke down the entire lifecycle into atomic states
I started by identifying each discrete state a ride can be in. After reviewing industry standards, academic mobility papers, and observing UI behavior from existing ride-hailing apps, I created a refined list of essential states:

1. **REQUESTED** – rider creates a ride request  
2. **SEARCHING** – system looks for available drivers  
3. **MATCHED** – driver is assigned but hasn’t accepted yet  
4. **DRIVER_ACCEPTED** – driver accepts the match  
5. **DRIVER_EN_ROUTE** – driver traveling to pickup  
6. **ARRIVED_AT_PICKUP**  
7. **RIDER_ONBOARD**  
8. **IN_PROGRESS** – trip underway  
9. **NEAR_DROPOFF** – optional predictive state  
10. **COMPLETED**  
11. **CANCELLED_BY_RIDER**  
12. **CANCELLED_BY_DRIVER**  
13. **CANCELLED_BY_SYSTEM** – safety net for failures  

Each state must have explicit entry and exit conditions. Documenting this clearly avoids ambiguous transitions that often cause rider-driver mismatches.

### 2. Defined strict state transition rules
A well-designed lifecycle behaves like a deterministic state machine. I defined what transitions are legal versus illegal.

Examples of **legal transitions:**
- REQUESTED → SEARCHING  
- SEARCHING → MATCHED  
- MATCHED → DRIVER_ACCEPTED  
- DRIVER_EN_ROUTE → ARRIVED_AT_PICKUP  
- ARRIVED_AT_PICKUP → RIDER_ONBOARD  
- IN_PROGRESS → COMPLETED  

Examples of **illegal transitions** (must be blocked):
- COMPLETED → IN_PROGRESS (cannot “undo” a finished trip)  
- REQUESTED → ARRIVED_AT_PICKUP (driver must accept and travel first)  
- DRIVER_EN_ROUTE → COMPLETED (cannot skip rider onboarding)  

Invalid transitions create inconsistent data, which leads to billing errors, safety concerns, and frustrated users. The entire system must enforce transition rules like a contract.

### 3. Studied idempotency requirements to avoid duplicate rides
Bad networks cause double taps, retries, or repeated events. I examined how to make lifecycle updates robust:

- Assign **idempotency keys** to ride creation  
- Ensure **driver accept** events cannot be duplicated  
- Use **“last write wins”** with server timestamps  
- Reject **out-of-order** events (e.g., “trip started” before “driver arrived”)  

This prevents issues like:
- two drivers believing they are matched to the same rider  
- ride creation being charged twice  
- trip completion being processed twice  

Barbados has pockets of weak signal, so idempotency is non-negotiable.

### 4. Designed failure-handling scenarios
Real-world mobility is messy. Phones die, cars get stuck, GPS drifts, and networks drop.  
I designed fallback and timeout flows:

**Scenario A – Driver accepts but goes offline**  
- Keep state in DRIVER_ACCEPTED for up to X seconds  
- If no heartbeats, move to CANCELLED_BY_SYSTEM  
- Automatically rematch rider  

**Scenario B – Rider cancels while driver en route**  
- Transition to CANCELLED_BY_RIDER  
- Notify driver with reimbursed cancellation fee if applicable  

**Scenario C – Duplicate “arrived” events**  
- First one updates state  
- Others ignored via idempotent handling  

These edge cases are essential for reliability.

### 5. Modeled concurrency and race conditions
In a distributed mobility system, multiple events often happen “at the same time.”  
Examples:

- Rider cancels at the exact moment driver accepts  
- Two drivers attempt to accept the same ride  
- Rider’s network delay causes late “update pickup” events  

I studied concurrency solutions:
- atomic conditional updates  
- transactionally locked ride rows  
- using Redis `SETNX` for distributed locks  
- globally sequenced event streams  

This ensures Bimride never ends up with conflicting trip states.

### 6. Mapped backend responsibilities
I mapped which microservice handles each part:

- **Ride Service:** manages lifecycle state  
- **Matching Service:** assigns drivers  
- **Location Service:** driver GPS updates  
- **Pricing Service:** computes fare at completion  
- **Notification Service:** sends instructions to rider/driver  
- **Payments Service:** handles final billing  

Each service emits events into an event stream.  
The ride state machine consumes these events in order.

### 7. Designed a visual timeline for the rider app
I converted lifecycle states into UI components:

- Spinner during SEARCHING  
- Driver profile card during MATCHED  
- ETA countdown during DRIVER_EN_ROUTE  
- “Meet at pickup spot” prompt at ARRIVED_AT_PICKUP  
- Live map during IN_PROGRESS  
- Fare summary at COMPLETED  

A clean backend lifecycle directly shapes a clean frontend.

### 8. Designed internal analytics hooks
Every state transition produces metrics:

- request-to-match time  
- match-to-accept time  
- accept-to-arrival time  
- pickup accuracy  
- cancellation rates  
- rider wait durations  

Bimride can later show these analytics to drivers for performance insights and use them internally for pricing adjustments.

---

## How Today’s Work Ties to Bimride

### 1. Reduces rider-driver mismatches
A precise lifecycle prevents:
- drivers thinking the rider cancelled when they didn’t  
- riders seeing outdated driver status  
- ghost matches  

This dramatically improves trust.

### 2. Improves ETA accuracy
A clean state machine helps determine:
- when the driver actually started traveling  
- when they arrived  
- when the trip truly began  

ETAs become more reliable.

### 3. Enables fair cancellation and refund logic
Clear state transitions allow Bimride to implement:
- grace windows  
- cancellation fees  
- dispute resolution  

Fairness drives user retention.

### 4. Smoother peak-hour performance
During tourist surges or weekend nightlife:
- correct matching  
- fast failure recovery  
- predictable state handling  

all keep the system stable.

### 5. Lets Bimride scale into a professional-grade platform
A strong lifecycle architecture is the foundation for:
- surge pricing  
- multi-island expansion  
- corporate rides  
- airport integrations  
- partner APIs  

Everything sits on top of a clean state machine.

