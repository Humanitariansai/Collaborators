# Daily Progress Report – October 6, 2025

## Overview
Today I studied **compilers and interpreters**, focusing specifically on how languages are parsed, optimized, and executed. Although this seems far removed from mobility products, understanding these concepts helps build faster backend code and evaluate performance bottlenecks.

---

## Activities
### **1. Reviewed Lexing and Parsing**
I learned how source code is converted into tokens and syntax trees.  
This gave me insight into how DSLs (domain-specific languages) could eventually help Bimride process routing rules or pricing formulas.

### **2. Studied Intermediate Representations (IRs)**
Compilers translate code into lower-level forms for optimization.  
This helped me understand how backend services can run faster and how code optimization matters at scale.

### **3. Explored JIT vs AOT Execution**
JIT compiles at runtime and AOT compiles beforehand.  
For Bimride’s backend, AOT languages (like Go or Rust) might offer stronger performance guarantees.

### **4. Experimented With a Tiny Expression Parser**
I built a small parser for arithmetic expressions to better understand syntax trees.  
This exercise helped me see how complex rules (like surge pricing logic) can be represented cleanly.

---

## How Today’s Work Ties to Bimride
### **1. Helps Build High-Performance Backends**
Understanding compilation helps choose the right language for Bimride’s backend services.

### **2. Improves Pricing Logic Efficiency**
Pricing models can be expressed cleanly and evaluated quickly.

### **3. Supports Routing Engine Optimization**
A routing engine written in an optimized language significantly reduces ETA latency.

### **4. Strengthens Technical Decision-Making**
Compiler-level understanding ensures Bimride uses languages and tools that scale reliably.
